## Summary of Day 37:

> *Learning in detail about Parallelization approach of Merging

#### Intro to Parallel Merge Kernel

Well, even mentioned yesterday about it. It is a GPU based implementation designed to effeciently merge two sorted arrays ($A$ and $B$) into a single sorted array ($C$) *using multiple threads*.

> #### ***So, the purpose??*** 
> - Utlize GPU threads to perform merge operation in parallel
> - Dividing works among threads effeciently
> - Using co-rank *(will discuss later on)* function to identify input subarrays ($A$ and $B$) for each thread based on its assigned output range in $C$.

#### How Parallel Merge Works:

> Kernel operation breakdown 🧑‍🍳.

**Step 1: Divide Output Array into Subarrays**

- Each thread is assigned a portion of the output array $C$ that it will generate.
- The starting index (`k_curr`) and ending index (`k_next`) of this portion are calculated using:
    ```cpp
    int k_curr = tid * elementsPerThread; // Start index in C
    int k_next = min((tid + 1) * elementsPerThread, m + n); // End index in C
    ```

> ***Spice Spice***🌶️ 
> 
> - ```tid```: Thread ID
> - ```elementsPerThread```: Number of elements each thread processes, calculated as:
> $$ \text{elementsPerThread} = \lceil \frac{m+n}{\text{total threads}}\rceil $$

**Step 2: Use Co-Rank Function to Determine Input Subarrays**

- For **each thread, the co-rank function is called twice**:
    - First with `k_curr` to compute the starting indices (`i_curr`, `j_curr`) for input subarrays from $A$ and $B$.
    - Second with `k_next` to compute the ending indices (`i_next`, `j_next`) for input subarrays.
- The corank function ensures that: 
    - The prefix subarray of $C$ up to index `k_curr` is generated by merging prefix subarrays of $A$ and $B$.
    - The ranges (`i_curr`, `i_next`) and (`j_curr`, `j_next`) define which elements from $A$ and $B$ contribute to the thread's portion of output array $C$.

**Step 3: Perform Sequential Merge**

- Each thread performs a sequential merge on its assigned input subarrays using the following call:
    ```cpp
    merge_sequential(&A[i_curr], i_next - i_curr,
                    &B[j_curr], j_next - j_curr,
                    &C[k_curr]);
    ```
- This merges elements from:
    - Subarray $A[$`i_curr:i_next`$]$.
    - Subarray $B[$`j_curr:j_next`$]$.

#### Well we did talk about Co-Rank earlier but what actually is it??

<details>
    <summary><b>Co-ranks Defined:</b></summary>
    The co-rank function is a critical component of the parallel merge kernel. It determines how to divide input arrays (A and B) into subarrays for each thread, ensuring that the merge process is both parallelized and correct. <b>This function uses binary search to efficiently compute the indices of the input subarrays that correspond to a given rank in the output array (C).</b>
</details>

**Purpose of Co-Rank Function:**

The co-rank function is designed to:

1. **Divide Work Among Threads:**

    For a given rank $k$ in the output array $C$, it determines how many elements come from array $A (i)$ and how many come from array $B (j)$.
    The relationship is: $k=i+j$.

2. **Ensure Correctness:**

    The co-rank ensures that the merged output remains sorted by finding the correct split points in $A$ and $B$.

3. **Enable Parallelism:**

    By dividing the input arrays into subarrays, each thread can independently perform its portion of the merge operation.

>***Code Implementation for Co-Rank:***
>
> [Click Here](corank.cu) to redirect towards the code implementation. 

> Misc. Codes:
> Using divide and Conquer rather than Binary Search. [Click Here](./div_conq.cu) to view.

---
<div align="center">
    <b>
        End of Day_37🫡
    </b>
</div>